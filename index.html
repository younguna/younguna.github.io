<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>younguna</title>

  
  <meta name="author" content="younguna">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="younguna"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="younguna" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">younguna</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/28/JavaScript-proto-VS-prototype/"><span>JavaScript __proto__ VS prototype</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/28/JavaScript-proto-VS-prototype/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-28T06:07:05.000Z">
          2019-07-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="JavaScript-proto-VS-prototype"><a href="#JavaScript-proto-VS-prototype" class="headerlink" title="JavaScript  __proto__ VS prototype"></a>JavaScript  __proto__ VS prototype</h1><blockquote>
<ul>
<li>단순히 생성한 객체(ex. const a = {})에는 prototype객체가 없다.</li>
<li>prototype은 함수객체에만 존재한다.</li>
<li>prototype은 함수를 new 키워드와 함께 constructor로 사용하고 싶을때 쓴다.</li>
<li><strong>proto</strong>는 모든 객체에 존재한다.</li>
<li><strong>proto</strong>를 이용하여 prototype chain을 검사한다.</li>
</ul>
</blockquote>
<ul>
<li><p>자바스크립트에서 함수는 객체이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"><span class="comment">//같은것이다.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>위의 함수를 선언하면 Person 객체와 Person’s prototype이라는 두개의 객체가 생긴다. <code>(실제로는 Person&#39;s prototype이라고 불리지는 않지만 이 글에서는 Person객체의 prototype이 가리키는 prototype객체를 말한다.)</code></p>
</li>
<li><p>Person의 prototype속성은 Person’s prototype을 가리키고 Person’s prototype은 constructor 속성으로 Person 객체를 가리킨다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.returnName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>위까지 완료되면 객체를 찍어내는 공장인 Person이라는 Constructor function을 만든 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> kim = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>
</li>
<li><p>위의 코드가 실행되면 kim이라는 객체가 만들어지는데 이 객체는 <strong>proto</strong>속성이 생기는데 이 속성은 Person’s prototype을 가리키게 된다.</p>
</li>
<li>즉 Person.prototype도 Person’s Prototype을 가리키고 kim.<strong>proto</strong>도 Person’s Prototype을 가리킨다.</li>
</ul>
<p><img src="https://imgur.com/pr7spGd.png"></p>
<ul>
<li>위의 그림에서 new Person()이 kim의 역할을 나타낸다.</li>
<li>kim의 <strong>proto</strong>는 kim을 생성한 Person의 prototype을 가리키고 그 prototype은 constructor 속성으로 다시 Person을 가리킨다.</li>
<li>kim의 <strong>proto</strong>는 Person의 prototype을 가리킨다 했는데 사실 Person의 prototype도 <strong>proto</strong>속성으로 다른 prototype을 가리킬 것이다.</li>
<li>위의 그림에서는 Animal의 prototype을 가리키고 있다. 이는 JavaScirpt에서 상속의 기본 개념이다.<ul>
<li>new Person인 kim객체는 Person의 인스턴스로써 Person의 Prototype의 returnName과 returnAge함수를 쓸 수 있는데 이것은 JavaScript가 kim객체의 prototype chain따라 Person의 prototype 객체에서 returnName과 returnAge를 찾아내었기 때문이다.</li>
<li>이런식으로 JavaScript는 <strong>proto</strong>속성을 따라 kim객체가  Animal의 prototype객체안에서 makeSount()를 찾아서 사용할 수 있도록 해준다.</li>
<li>이는 마치 Person이 Animal을 상속한 것과 같은 효과를 낸다.</li>
<li>참고로 <strong>proto</strong>의 연결의 마지막에는 최상위 객체인 Object의 prototype 객체가 있으며 함수나 속성을 prototype chain을 모두 찾은 후 찾지 못한다면 속성의 경우 undefined을 리턴하고 함수의 경우 에러가 발생한다.</li>
</ul>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/자바스크립트/">자바스크립트</a><a href="/tags/JavaScript/">JavaScript</a><a href="/tags/JS/">JS</a><a href="/tags/prototype/">prototype</a><a href="/tags/proto/">__proto__</a><a href="/tags/상속/">상속</a><a href="/tags/프로토타입/">프로토타입</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/22/git-git-fork-flow/"><span>git-git fork flow</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/22/git-git-fork-flow/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-22T01:58:42.000Z">
          2019-07-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="git-fork-부터-이루어지는-오픈소스-프로젝트-git에-관하여"><a href="#git-fork-부터-이루어지는-오픈소스-프로젝트-git에-관하여" class="headerlink" title="git fork 부터 이루어지는 오픈소스/프로젝트 git에 관하여"></a>git fork 부터 이루어지는 오픈소스/프로젝트 git에 관하여</h1><p><img src="https://i.imgur.com/cU1Jbut.png" width="60%" style="margin:0 auto; display:block"></p>
<h2 id="Repository-설명"><a href="#Repository-설명" class="headerlink" title="Repository 설명"></a>Repository 설명</h2><ul>
<li><p>original repository : 프로젝트 혹은 오픈소스의 원 원격 리포지토리, 오픈소스의 본 소스코드들이 브랜치와 함께 유지되고 있으며 현재 개인은 이 리포지토리에 권한이 전혀 없다.</p>
</li>
<li><p>my remote repository : 나의 원격 리포지토리로써 original repository에서 fork해 온 것이다. fork는 github같은 원격 git 서비스 상에서 수행되는 git clone 이다. fork해온 나의 원격 리포지토리에 내가 작업하는 코드들을 push할 수 있다. 만약 이 원격 리포지토리에 같이 작업하는 팀원이 있다면 그가 push한 코드를 pull할 수 도 있다.</p>
</li>
<li><p>local repository : 그림에서 가장 밑에 존재하는 리포지토리이며 내가 실제로 작업하는 컴퓨터에 존재한다. master 브랜치에서 브랜치를 파생하여 작업하며 그것을 push하면 my remote repository에도 그 브랜치가 생성된다. 작업한 이력을 남긴다.</p>
</li>
</ul>
<h2 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h2><p>[1] : original repository에서 내 원격 remote repository(나의 github 계정 등)으로 git fork 해온다. public되어있는 오픈소스는 git fork하는데 전혀 영향이 없다. my remote repository에 나의 원격 리포지토리가 생성된다.<br>[2] :  my remote repository에 생성된 코드를 작업하기 위하여 local repsoitory로 git clone 해온다.<br>[3] :  그림에서는 working branch라는 이름으로 브랜치를 생성하여 작업한다. 본인이 원하는 브랜치명으로 브랜치를 파생하여 작업한다.<br>[4] : 여러 작업을 수행한 후 원격 저장소에 저장하기 위해 push를 수행한다.<br>[5] :  original repository에 개인은 권한이 없으므로 본인이 작업을 수행하고 my remote repository에 저장한 나의 코드를 github의 경우 Pull Request를 생성하여 무엇을 작업했는지 등등을 작성하고 요청을 보낸다. original repository의 주인이나 단체가 Pull request를 점검하고 해당 코드를 자신들의 original repository에 merge 할지 말지를 결정한다.</p>
<ul>
<li>Pull request가 거부되었을 시, 그에 대한 이유등을 알려주는 친절한 owner가 있는 반면 확인하지도 않는 owner도 있으며 아무 이유 없이 거부하는 owner도 있다.</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/git/">git</a><a href="/tags/github/">github</a><a href="/tags/git-fork/">git fork</a><a href="/tags/project/">project</a><a href="/tags/open-source/">open source</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/22/Logic-gate-endian/"><span>Logic gate-endian</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/22/Logic-gate-endian/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-21T23:50:39.000Z">
          2019-07-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="빅엔디언-리틀엔디언"><a href="#빅엔디언-리틀엔디언" class="headerlink" title="빅엔디언 리틀엔디언"></a>빅엔디언 리틀엔디언</h1><h3 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h3><ul>
<li>컴퓨터 메모리와 같은 1차원의 공간에 여러개의 원소를 배열하는 방법이다. 쉽게 말하여 한 줄의 데이터를 왼쪽부터 쓰고 읽느냐 오른쪽부터 쓰고 읽느냐를 말한다. 컴퓨터공학의 관점에서는 특히 바이트를 배열하는 방법을 의마하며 바이트 순서(Byte order)라 한다.</li>
</ul>
<h3 id="유래"><a href="#유래" class="headerlink" title="유래"></a>유래</h3><ul>
<li>조너선 스위프트의 소설 &lt;걸리버 여행기&gt;에서 달걀을 깰 때 뭉툭한 끝(big-end)을 먼저 깨는 사람들(big-endian)과 뾰족한 끝(little-end)을 먼저 깨는 사람들(little-endian) 사이에 토론에서 유래 되었다.</li>
<li>컴퓨터공학에서 의 엔디언은 대니 코언(Danny Cohen)이 이런 플레임을 잠재우기 위해 1980년에 쓴 On Holy Wars and a Plea for Peace라는 글에서 유래 되었다.</li>
</ul>
<h3 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h3><ul>
<li>빅엔디언은 쉽게 설명하여 사람이 숫자를 쓰는 방법대로 상위바이트부터 하위주소에 기록하는 것이다. 101010 이라는 바이트가 존재한다면 이는 메모리에 101010으로 기록된다.</li>
<li>리틀엔디언은 쉽게 설명하여 사람이 숫자를 쓰는 방법의 반대로 하위바이트부터 하위주소에 기록하는 것이다. 101010 이라는 바이트가 존재한다면 이는 메모리에 010101로 기록된다.</li>
<li>PDP-11 등 몇몇 아키텍쳐는 2바이트 단위와 1바이트 단위로 서로 다른 순서를 사용하는 미들엔디언이라는 컨셉도 존재한다.</li>
<li>리틀엔디언은 x86 아키텍쳐를 사용하는 인텔이 대표적으로 사용하여서 “인텔 포맷”이라고 불리기도 한다.</li>
<li>하지만 네트워크는 특성상 네트워크 주소를 빅엔디언으로 사용한다.라우팅이 접두 부호로 이루어져 있기 때문이다.</li>
<li>빅엔디언은 위의 언급처럼 사람이 읽고 쓰는 방식과 동일하기 때문에 개발자가 소프트웨어 디버깅을 할 때 편리한 점이 있다.</li>
<li>반대로 리틀 엔디언은 사람이 읽는데는 불편함이 있지만 메모리에 저장된 값의 하위 바이트만 사용할때 별도로 계산이 필요없다는 장점을 가지고 있다. 예를 들어 32비트 숫자가 리틀엔디언으로 2A 00 00 00같이 존재할때, 하위 16비트나 8비트 값을 얻을때는 앞의 한두바이트만 분리하면 바로 얻을 수 있다. 하지만 이를 빅엔디언 방식으로 표현했다면 주소에 2~3바이트를 더하여 구하여야 한다.</li>
</ul>
<h3 id="note"><a href="#note" class="headerlink" title="note"></a>note</h3><ul>
<li>가산기가 덧셈을 할때 LSB(Least Significant Bit, 최하위 비트)에서 시작 하여 carry와 sum을 구하는 계산을 하는데 첫 바이트가 LSB인 리틀엔디언은 가산기가 조금더 단순하게 설계될 수 있다. 하지만 빅엔디언은 마지막 바이트부터 첫 바이트로 역방향으로 진행해야 하는 설계를 가져야한다. 그러나 최신의 프로세서들은 여러개의 바이트를 동시에 읽어들여 동시에 덧셈을 수행하므로 두 엔디언에서 사실상 차이가 없다고 한다.</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/논리게이트/">논리게이트</a><a href="/tags/CPU/">CPU</a><a href="/tags/빅엔디언/">빅엔디언</a><a href="/tags/리틀엔디언/">리틀엔디언</a><a href="/tags/엔디언/">엔디언</a><a href="/tags/endian/">endian</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/18/JavaScript-Array-methods/"><span>JavaScript Array methods</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/18/JavaScript-Array-methods/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-18T08:42:53.000Z">
          2019-07-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="JavaScript-Array-Methods"><a href="#JavaScript-Array-Methods" class="headerlink" title="JavaScript Array Methods"></a>JavaScript Array Methods</h1><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><ul>
<li>이 메소드는 단순히 배열의 모든 원소에 대해 콜백함수를 실행합니다.</li>
<li>forEach의 콜백함수는 다음의 파라미터를 다룬다.<ul>
<li>currentValue 현재 원소</li>
<li>index 현재 원소의 인덱스</li>
<li>array 원 배열</li>
<li>thisArg 콜백을 실행할 때 this로 사용됨<h4 id="코드예제"><a href="#코드예제" class="headerlink" title="코드예제"></a>코드예제</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [<span class="string">'item1'</span>, <span class="string">'item2'</span>, <span class="string">'item3'</span>];</span><br><span class="line"><span class="keyword">const</span> copy = [];</span><br><span class="line"><span class="comment">// for iteration</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;items.length; i++) &#123;</span><br><span class="line">  copy.push(items[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// same operation with forEach</span></span><br><span class="line">items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  copy.push(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>위의 코드를 실행하면 item의 원소들은 각각 콜백함수로 넘어가 콜백함수 안에 구현된 행위를 한다. 위의 경우에는 전역의 copy배열에 각각의 원소를 push하는 행위를 하게 된다. 특별히 반환되는 것은 없고 undefined가 반환된다.</p>
</blockquote>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul>
<li>이 메소드는 배열의 모든 원소에 대해 콜백함수를 적용하여 그 결과를 새로운 배열에 push에 넣어 리턴하는 JavaScript Array의 메소드다.</li>
<li>reduce와 함께 활용도가 매우높다.</li>
<li>map의 콜백함수가 다루는 파라미터는 forEach와 동일하다.<ul>
<li>currentValue, index, array, thisArg</li>
</ul>
</li>
<li>최종적으로 배열이 리턴된다.<h4 id="코드예제-1"><a href="#코드예제-1" class="headerlink" title="코드예제"></a>코드예제</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">const</span> doubles = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;<span class="keyword">return</span> num * <span class="number">2</span>;&#125;);</span><br><span class="line"><span class="comment">// &gt;&gt;&gt; [2,8,18]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>위의 코드를 실행하면 배열의 각원소마다 콜백함수가 실행되고 그 리턴값을 배열에 넣는다. 모든 원소들이 이 행위를 마치고 리턴값들이 모인 배열을 최종적으로 리턴한다.</p>
</blockquote>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><ul>
<li>이 메소드는 배열의 모든 원소에 대해 콜백함수를 적용하여 boolean을 받아 true인 경우의 원소만을 모아 배열에 넣어 리턴하는 JavaScript Array 메소드다.</li>
<li>filter의 콜백 함수는 true나 false를 반환해야 filter가 제대로 작동할 수 있다.<ul>
<li>currentValue, index, array, thisArg의 파라미터들을 filter의 콜백함수가 사용하며 map과 동일한 기능을 한다.<h4 id="코드예제-2"><a href="#코드예제-2" class="headerlink" title="코드예제"></a>코드예제</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBiggerThanTen</span>(<span class="params">value</span>) </span>&#123;<span class="keyword">return</span> value &gt; <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">let</span> filtered = [<span class="number">10</span>, <span class="number">11</span>, <span class="number">112</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].filter(isBiggerThanTen);</span><br><span class="line"><span class="comment">// filtered = [11, 112, 130, 44]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>위의 코드를 실행하면 10은 콜백함수에서 false를, 11은 콜백함수에서 true를 리턴할 것이다. 이러한 행위를 모든 원소에 적용하면 <code>false, true, true, false, true, true</code>가 계산될 것이다. 여기서 true의 값을 리턴한 <code>11, 112, 130, 44</code>만 <code>filtered</code>변수에 반환될 것이다.</p>
</blockquote>
<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><ul>
<li>이 메소드는 배열의 각 원소마다 reducer라고 불리우는 콜백함수를 진행하고 마지막엔 하나의 결과를 반환하는 JavaScirpt Array의 메소드이다.</li>
<li>배열 메소드 중 매우 활용도가 높다고 불려진다.</li>
<li>위의 reducer는 네 개의 파라미터를 다룬다.<ul>
<li>accumulator, currentValue, currentIndex, originalArray</li>
</ul>
</li>
<li>reducer가 실행될때마다 결과값은 accumulator에 할당된다.<h4 id="코드예제-3"><a href="#코드예제-3" class="headerlink" title="코드예제"></a>코드예제</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, currentIndex, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>위의 코드를 실행하면 배열의 각 원소마다 reducer가 실행되고 reducer가 리턴하는 accumulator + currentValue값이 다음 번의 reducer실행에서 accumulator로 할당되어 실행된다. 제일 마지막에 accumulator의 값이 최종적으로 리턴된다.</p>
</blockquote>
<p>reduce를 자세히 보면 map과 비슷한 작동방식이 있다는 것을 알 수 있다. 밑은 mdn에서 예시로 보여주는 reduce로 만드는 map메소드다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.mapUsingReduce) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.mapUsingReduce = <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">mappedArray, currentValue, index, array</span>) </span>&#123;</span><br><span class="line">      mappedArray[index] = callback.call(thisArg, currentValue, index, array);</span><br><span class="line">      <span class="keyword">return</span> mappedArray;</span><br><span class="line">    &#125;, []);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><ul>
<li>some 메소드는 배열의 각 원소가 콜백함수의 판별을 통과하는지 확인하고 만약 하나라도 통과하는 경우에는 최종적으로 true를 리턴하고 그렇지 않다면 false를 리턴한다.</li>
<li>some의 콜백함수가 다루는 파라미터는 forEach와 동일하다.<ul>
<li>currentValue, index, array, thisArg<h3 id="코드예제-4"><a href="#코드예제-4" class="headerlink" title="코드예제"></a>코드예제</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>].some(<span class="function"><span class="params">elem</span> =&gt;</span> elem &gt; <span class="number">10</span>);  <span class="comment">// false</span></span><br><span class="line">[<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>].some(<span class="function"><span class="params">elem</span> =&gt;</span> elem &gt; <span class="number">10</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>위의 코드는 배열의 각 원소가 10보다 큰 수인지 확인하여 true/false를 리턴하는 콜백함수를 통과한 후 하나라도 true값을 가지게된다면 최종적으로 true를 반환한다.</p>
</blockquote>
<h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><ul>
<li>every 메소드는 some과 매우 흡사한 기능을 하지만 모든 원소가 콜백함수를 통해 true값을 가질때만 최종적으로 true를 리턴하고 나머지 경우엔 false를 리턴한다.</li>
<li>빈 배열에서 사용하면 무조건 true를 반환한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">12</span>, <span class="number">5</span>, <span class="number">130</span>, <span class="number">44</span>].every(<span class="function"><span class="params">elem</span> =&gt;</span> elem &gt;= <span class="number">10</span>); <span class="comment">// false</span></span><br><span class="line">[<span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">130</span>, <span class="number">44</span>].every(<span class="function"><span class="params">elem</span> =&gt;</span> elem &gt;= <span class="number">10</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>두 배열 중 위 배열에서 10보다 작은 5가 존재하므로 최종적으로 false를 리턴하고 밑의 배열은 모든 원소가 10보다 크므로 최종적으로 true를 반환한다.</p>
</blockquote>
<h2 id="함수형-프로그래밍"><a href="#함수형-프로그래밍" class="headerlink" title="함수형 프로그래밍"></a>함수형 프로그래밍</h2><ul>
<li>안정적인 프로그램을 만들기 위해 입력과 출력이 철저히 통제된 순수 함수 및 부수 효과(Side-effect)를 최소화한 함수 위주의 프로그래밍</li>
<li>간결하고 가독성 높은 프로그램을 작성할 수 있으며 동시성 작업을 더 안전하게 구현할 수 있다.</li>
<li>함수를 특별하게 취급하지 않는 프로그래밍 패러다임</li>
</ul>
<h2 id="함수형-프로그래밍에서-forEach-map-filter"><a href="#함수형-프로그래밍에서-forEach-map-filter" class="headerlink" title="함수형 프로그래밍에서 forEach, map, filter"></a>함수형 프로그래밍에서 forEach, map, filter</h2><ul>
<li>위에서의 언급처럼 함수형 프로그래밍은 입력과 출력이 철저히 통제되며 부수 효과를 최소화 해야한다. 이는 함수가 함수 밖의 컨텍스트를 만지는 일(부수 효과)가 최소화 되야 하는데 이는 map, filter, reduce같은 배열의 메소드의 특징과 잘 맞아 떨어진다고 볼 수 있다. 그 이유는 위의 메소드들은 배열을 처리하여 새로운 배열을 리턴하고 원 배열은 그대로 두기 때문이다. 반면 forEach는 원 배열을 반드시 바꿔야 하도록 강제하는 것은 전혀 없지만 map이나 reduce처럼 새 배열을 강제하지 않고 index를 이용하면 원배열을 변경하는 것이 가능하다.</li>
</ul>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/javascript/">javascript</a><a href="/tags/js/">js</a><a href="/tags/es6/">es6</a><a href="/tags/Array/">Array</a><a href="/tags/methods/">methods</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/18/es6-basics/"><span>es6 basics</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/18/es6-basics/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-18T08:40:57.000Z">
          2019-07-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="JavaScript-ES6-Basics"><a href="#JavaScript-ES6-Basics" class="headerlink" title="JavaScript ES6 Basics"></a>JavaScript ES6 Basics</h1><ul>
<li><p>‘${shape.toString()} : ${config.shapeErrorMsg}’</p>
<ul>
<li>template literals : 내장된 표현식을 허용하는 문자열 리터럴로, 문자열과 문자 보간 기능을 사용할 수 있다. 실제로는 따옴표 대신에 backtick이 쓰인다.</li>
</ul>
</li>
<li><p>여러 개의 전역변수를 선언할 때 하나의 객체 내에 선언해 주면 충돌을 어느정도 방지할 수 있다.</p>
</li>
<li><p>== 와 ===의 차이</p>
<ul>
<li>== : 자료형이 달라도 값이 같다면 true </li>
<li>=== : 자료형이 같으면서 값이 같아야 true</li>
</ul>
</li>
<li><p>some()</p>
<ul>
<li>array.some( ~~ ) 배열 내의 값 중 하나 이상 ~~의 조건을 만족한다면 true를 반환</li>
</ul>
</li>
<li><p>join()</p>
<ul>
<li>배열 안의 요소들을 string으로 바꿔주며 인자를 전달할 시에는 배열을 출력할 때 사이에 인자를 함께 출력해준다</li>
</ul>
</li>
<li><p>예외처리를 할 때, if문으로 예외를 throw하는 방법도 있지만 프로그램에서 기본적으로 throw하는 예외를 catch했을 때 처리하는 방법도 있다.</p>
</li>
<li><p>어떤 변수를 로컬변수로 사용할 때, var 보다는 let과 const로 선언하는 쪽이 좋다.</p>
</li>
<li><p>var와 let의 스코프 차이</p>
<ul>
<li>var는 블록단위의 지역스코프를 보장해 주지 않지만 let은 보장해 준다.</li>
</ul>
</li>
<li><p>코드 내에서 동작하는 데에 영향은 없더라도 형식을 통일해 주는 것이 좋다.</p>
<ul>
<li>ex ) “ㅇ” 와 ‘ㅇ’ 를 같이 사용하는 것은 좋지 않다.</li>
</ul>
</li>
</ul>
<ul>
<li><p>함수표현방법</p>
<ul>
<li><p>일반적 함수 표현</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'ㅇ'</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>변수를 이용한 함수 표현</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> printName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">'ㅇ'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>arrow function</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getName = <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="string">"Kim "</span> + name;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>순수함수</p>
<ul>
<li>동일한 인자를 주었을 때 항상 같은 값을 반환하는 함수</li>
<li>함수가 자체적으로 외부 상태를 변경하지 않는다 ( 부수 효과가 없다 )</li>
<li>장점<ul>
<li>재사용성이 높다</li>
<li>입력과 결과가 분리되어 있어서 어떻게 사용되는지 신경 쓸 필요가 없다.</li>
</ul>
</li>
</ul>
</li>
<li><p>ES2015에서의 유용한 문법</p>
<ul>
<li>구조 분해 할당</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> [a, b] = arr;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>위와 같은 구조로 저장된 값들을 다른 변수에 할당할 때 불필요한 코드를 줄이면서 간결하게 작성할 수 있다.<br><code>[arr[0], arr[1]] = [arr[1], arr[0]]</code> 와 같이 swap도 가능</p>
</blockquote>
<ul>
<li>arrow function</li>
<li>template literals</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/javascript/">javascript</a><a href="/tags/js/">js</a><a href="/tags/es6/">es6</a><a href="/tags/es2015/">es2015</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/18/git-basics/"><span>git basics</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/18/git-basics/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-18T08:38:59.000Z">
          2019-07-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="git-basics"><a href="#git-basics" class="headerlink" title="git basics"></a>git basics</h1><h2 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h2><ul>
<li>새로운  git 저장소가 만들어짐</li>
</ul>
<h2 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h2><ul>
<li><code>git clone /로컬/저장소/경로</code><ul>
<li>로컬 저장소(repo)를 복제(clone)</li>
</ul>
</li>
<li><code>git clone username@host:/원격/저장소/경로</code><ul>
<li>원격 서버의 저장소를 복제</li>
</ul>
</li>
</ul>
<h2 id="git-작업의-흐름"><a href="#git-작업의-흐름" class="headerlink" title="git 작업의 흐름"></a>git 작업의 흐름</h2><ul>
<li>로컬 저장소는 git이 관리하는 세 가지로 구성되어 있다.</li>
<li>첫 번재는 작업 디렉토리 - 실제 파일들로 이루어져 있다.</li>
<li>두 번째는 인덱스(Index) - 준비 영역 (staging area) 역할을 한다.</li>
<li>세 번째는 HEAD - 최종 확정본(commit)을 나타낸다.</li>
</ul>
<h2 id="Add-amp-Commit"><a href="#Add-amp-Commit" class="headerlink" title="Add &amp; Commit"></a>Add &amp; Commit</h2><ul>
<li><code>git add &lt;파일이름&gt;</code></li>
<li><code>git add *</code> : 현 디렉토리 모두 추가<ul>
<li>위의 명령어로 변경된 파일을 인덱스에 추가할 수 있다.</li>
</ul>
</li>
<li><code>git commit -m &quot;이번 확정본에 대한 설명&quot;</code><ul>
<li>git의 기본 작업 흐름에서 첫 단계에 해당한다.</li>
<li>이 명령어를 내려 확정을 하면 변경된 파일이 HEAD에 반영된다.</li>
<li>원격 저장소는 아직 반영되지 않음</li>
</ul>
</li>
</ul>
<h2 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h2><ul>
<li>위의 순서까지 진행했다면 로컬 저장소의 HEAD에만 변경 내용이 존재한다.</li>
<li><code>git push origin master</code>를 통해 로컬의 master 브랜치를 원격 저장소의 master 브랜치에 발행할 수 있다.</li>
<li>만약 기존의 원격 저장소에서 복제한 로컬 저장소가 아니라면 <code>git remote add origin &lt;원격서버주소&gt;</code>를 통해 git에게 알려줘야 한다.</li>
</ul>
<h2 id="Branching"><a href="#Branching" class="headerlink" title="Branching"></a>Branching</h2><ul>
<li>브랜치는 안전하게 격리된 상태에서 코딩을 할 때 사용한다.</li>
<li>저장소를 만들면 기본의 master 브랜치가 만들어진다.</li>
<li>master 브랜치에서 다른 브랜치를 만들고 그 브랜치에서 작업을 진항하고 나중에 작업이 완료되면 master 가지로 돌아와 병합(merge)한다.</li>
<li><code>git checkout -b feature_x</code> feature_x라는 브랜치를 만들고 checkout 한다.</li>
<li><code>git checkout master</code>를 통해 master 브랜치를 다시 checkout한다.</li>
<li><code>git branch -d feature_x</code>를 통해 브랜치를 삭제할 수 있다.</li>
<li>새로 만든 브랜치는 원격 저장소로 전송하기 전까지는 다른사람들이 볼 수 없다.</li>
</ul>
<h2 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h2><ul>
<li><p><code>git pull</code>을 통해 로컬 저장소를 원격 저장소에 맞춰 갱신할 수 있다.</p>
<ul>
<li>로컬 작업 디렉토리에 받아지고(fetch), 병합(merge) 된다.</li>
</ul>
</li>
<li><p>다른 브랜치에 있는 변경 내용을 현재 브랜치로 병합하려면 <code>git merge &lt;브랜치명&gt;</code>을 통해 병합할 수 있다.</p>
</li>
<li><code>git diff &lt;원브랜치&gt; &lt;비교브랜치&gt;</code>를 통해 merge전 어떻게 바뀌는지 비교해 볼 수 있다.</li>
</ul>
<h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><ul>
<li>SW의 새 버전을 발표할 때마다 꼬리표를 달아놓으면 식별하기 편리하다.</li>
<li><code>git tag 1.0.0 1b2e1d63ff</code>같은 명령어를 사용하여 tag를 달 수 있으며 1.0.0이 태그이고 뒤의 부분은 태그가 가리킬 확정본 식별자 입니다.</li>
<li><code>git log</code> 명령어를 통해 확정본 식별자를 얻을 수 있다.</li>
</ul>
<h2 id="로컬-변경-내용-되돌리기"><a href="#로컬-변경-내용-되돌리기" class="headerlink" title="로컬 변경 내용 되돌리기"></a>로컬 변경 내용 되돌리기</h2><ul>
<li><code>git checkout -- &lt;파일 이름&gt;</code> 명령어는 로컬의 변경 내용을 되돌릴 수 있습니다. 로컬의 변경 내용을 변경 전 상태(HEAD)로 되돌린다. <ul>
<li>다만 이미 인덱스에 추가된 변경 내용과 새로 생성한 파일은 그대로 남는다.</li>
</ul>
</li>
<li>로컬에 있는 모든 변경 내용과 확정본을 포기하려면 <code>git fetch origin || git reset --hard origin/master</code>으로 원격 저장소의 최신 이력을 가져오고 로컬 master 브랜치가 원격 저장소의 master 브랜치 이력을 가리킬 수 잇다.</li>
</ul>
<h2 id="git-fork-to-pull-request"><a href="#git-fork-to-pull-request" class="headerlink" title="git fork to pull request"></a>git fork to pull request</h2><ul>
<li>origin remote repo에서 fork를 하여 자신의 remote repo에 복사한다.<ul>
<li>실제로 fork는 git에 존재하는 명령어가 아니며 github같은 원격저장소 내에서의 clone과 비슷하다고 볼 수 있다.</li>
</ul>
</li>
<li>나의 원격 저장소에서 로컬로 git clone한다.</li>
<li>로컬에서 브랜치를 생성하여 작업 후 브랜치를 master로 merge후 master를 push 한다.</li>
<li>나의 remote repo의 master브랜치를 fork한 origin remote repo에 PR을 날린다.</li>
<li>물론 origin remote repo가 어떻게 브랜칭을 하느냐에 따라 위의 과정은 매우 달라질 수 있다.</li>
</ul>
<h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><ul>
<li><code>git pull</code>을 실행하면 원격 저장소의 내용을 가져와 자동으로 병합 작업을 실행하게 됩니다.</li>
<li>단순히 원격 저장소의 내용을 확인만 하고 로컬 데이터와 병합은 하고 싶지 않은 경우에는 <code>git fetch</code> 명령어를 사용할 수 있습니다.</li>
<li>fetch한 상태에서 원격 저장소의 내용을 로컬 저장소의 master 브랜치에 통합하고 싶은 경우에는, “FETCH_HEAD” 브랜치를 merge하면 됩니다. pull 명령어는 내부적으로 fetch + merge 입니다.</li>
</ul>
<h2 id="github-fork에서-pull-request까지"><a href="#github-fork에서-pull-request까지" class="headerlink" title="github fork에서 pull request까지"></a>github fork에서 pull request까지</h2><ul>
<li>원본 원격저장소에서 사용자의 원격저장소로 복사(fork) 함<ul>
<li>실질적으로 git clone. 원격 저장소내의 기능</li>
</ul>
</li>
<li>사용자의 원격 저장소에서 사용자 개인 로컬저장소로 복사(clone) 함</li>
<li>로컬 저장소에서 작업 후 add 명령어를 이용해 stage에 올림</li>
<li>commit 명령어로 stage에 올라간 변경사항을 확정</li>
<li>push를 이용해 로컬 저장소에 commit된 변경사항을 원격 저장소에 반영</li>
<li>pull request(PR)를 이용해 개인 원격저장소의 변경 사항을 원본 원격저장소에 반영요청<ul>
<li>이때 여러가지의 상황에 따라 브랜치간으로 이루어 질 수 있음</li>
</ul>
</li>
<li>승인이 이루어지면 원격저장소에 변경 사항 반영</li>
</ul>
<h2 id="git-add-와-git-commit-시-git의-내부"><a href="#git-add-와-git-commit-시-git의-내부" class="headerlink" title="git add 와 git commit 시 git의 내부"></a>git add 와 git commit 시 git의 내부</h2><ul>
<li><code>git add</code> 동작을 수행하면 index(스테이지) 에 object 이름과 실제 파일 이름이 추가되고, 오브젝트에 blob 타입으로 파일 내용이 추가됨</li>
<li>blob 파일이란 바이너리 라지 오브젝트의 약자로, 대용량 데이터를 저장하기 위한 이진 데이터의 모임을 말함 </li>
<li><code>git commit</code> 동작을 수행하면 object에 commit 객체와 tree객체가 추가됨 </li>
<li>tree 객체는 스테이지에 올라온 것들을 snapshot 을 찍어 저장하고, commit객체는 만들어진 tree 객체와 부가적인 정보를 저장함</li>
</ul>
<h2 id="git-workflow"><a href="#git-workflow" class="headerlink" title="git-workflow"></a>git-workflow</h2><ul>
<li>git-workflow가 필요한 이유는 안전한 개발을 위해서임</li>
<li>개발자가 자유롭고 안전하게 개발할 수 있어 개발 생산성을 향상시킴</li>
<li>대표적인 git-branch 전략은 master와 develop, feature, release, hotfix로 구분해서 필요에따라 생성해 작업하는 전략을 말함</li>
<li><code>develop</code> 브랜치의 경우 다음 출시 버전을 개발하는 브랜치</li>
<li><code>feature</code> 브랜치의 경우 기능을 개발하는 브랜치</li>
<li><code>release</code> 브랜치는 이전 출시 버전을 준비하는 브랜치</li>
<li><code>hotfix</code> 브랜치는 출시 버전에서 발생한 버그를 수정하는 브랜치</li>
<li>팀의 상황에 따라 여러가지로 branch를 유지할 수 있음</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/git/">git</a><a href="/tags/github/">github</a><a href="/tags/깃/">깃</a><a href="/tags/깃허브/">깃허브</a><a href="/tags/깃헙/">깃헙</a><a href="/tags/버전관리/">버전관리</a><a href="/tags/SVN/">SVN</a><a href="/tags/개발/">개발</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/04/브라우저-뒤에서-일어나는일/"><span>브라우저 뒤에서 일어나는 일</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/04/브라우저-뒤에서-일어나는일/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-04T05:03:47.000Z">
          2019-07-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <hr>

<h1 id="브라우저-뒤에서-일어나는-일"><a href="#브라우저-뒤에서-일어나는-일" class="headerlink" title="브라우저 뒤에서 일어나는 일"></a>브라우저 뒤에서 일어나는 일</h1><hr>

<h3 id="브라우저"><a href="#브라우저" class="headerlink" title="브라우저"></a>브라우저</h3><ol>
<li>URL에 입력된 값을 브라우저 내부에서 결정된 규칙에 따라 그 의미를 조사한다.</li>
<li>조사된 의미에 따라 HTTP Request 메세지를 만든다.</li>
<li>만들어진 메세지를 웹 서버로 전송한다.</li>
</ol>
<ul>
<li>이때 만들어진 메세지 전송은 브라우저가 직접하는 것이 아니며 OS에 의뢰하여 메세지를 전달한다.</li>
<li>OS에 송신을 의로할 때는 도메인 명이 아니라 IP주소로 메세지를 받을 상대를 지정해야 하는데 이 과정에서 DNS(Domain Name Service)에 조회한다.</li>
</ul>
<h3 id="프로토콜-스택-LAN-어댑터"><a href="#프로토콜-스택-LAN-어댑터" class="headerlink" title="프로토콜 스택, LAN 어댑터"></a>프로토콜 스택, LAN 어댑터</h3><ol>
<li>프로토콜 스택(OS에 내장된 네트워크 제어용 스프트웨어)이 브라우저로 메세지를 받는다.</li>
<li>브라우저로부터 받은 메세지를 패킷 속에 저장한다.</li>
<li>수신처 주소 등의 제어정보를 덧붙인다.</li>
<li>패킷을 LAN 어댑터에 넘긴다.</li>
<li>LAN 어댑터는 패킷을 물리적 전기적 신호로 변환시킨다.</li>
<li>신호를 LAN 케이블에 송출시킨다.</li>
</ol>
<ul>
<li>프로토콜 스택은 계층화된 구조로 모여있는 프로토콜의 집합을 의미합니다. 계층을 나누는 목적은 매우 복잡한 네트워크에서 프로토콜의 역할을 분담하기 위해서입니다. 한 계층에 속하는 하나의 프로토콜이 인접한 계층의 다른 프로토콜과 통신을 합니다.</li>
<li>프로토콜 스택은 통신 중 오류가 발생하면 이 제어 정보를 사용하여 고쳐서 전송하거나 각종 상황을 조절하는 등 다양한 역할을 수행한다.</li>
</ul>
<h3 id="허브-스위치-라우터"><a href="#허브-스위치-라우터" class="headerlink" title="허브, 스위치, 라우터"></a>허브, 스위치, 라우터</h3><ol>
<li>LAN 어댑터가 송신한 패킷은 스위칭 허브를 경유하여 인터넷 접속용 라우터에 도착한다.</li>
<li>라우터는 패킷을 서비스 프로바이더(통신사)에게 전달한다.</li>
<li>패킷은 인터넷으로 진입하게 된다.</li>
</ol>
<ul>
<li>허브는 리피터와 같이 전기적인 신호를 증폭시켜 LAN의 전송거리를 연장시키고 여러대의 장비(컴퓨터)를 연결해 LAN에 접속할 수 있도록 한다.</li>
<li>리피터는 단순히 전기적인 신호만 증폭시키는 역할을 한다. UTP케이블의 최대 전송거리가 100m이기 때문에 리피터를 이용하여 신호를 증폭시킬 수 있다.</li>
<li>스위치는 연결되어 있는 모든 장비의 IP와 MAC주소를 테이블로 유지하고 있다. 프레임이 자신에게 수신되면 그것의 목적지를 파악하여 그 디바이스에게 프레임을 보내준다. </li>
<li>라우터는 둘 혹은 그 이상의 네트워크와 네트워크 간 데이터 전송을 위해 최적 경로를 설정해 주며 데이터를 해당 경로를 따라 한 통신망에서 다른 통신망으로 통신할 수 있도록 도와주는 인터넷 접속 장비이다.</li>
<li>ISP(Internet Service Provider)업체에서 제공하는 한 개의 인터넷 IP Address로 여러대의 장비들이 인터넷을 공유할 수 있는 기능을 제공합니다. 주로 사람들이 공유기를 이야기할때는 가정에서 사용하는 소용량 라우터를 의미하며 ISP에서 할당받은 하나의 공인 IP를 내부 네트워크에서 여러개의 IP 주소로 변환 사용가능하기  때문에 한 대의 장비에서만 인터넷 접속이나 외부 네트워크와 연결되는 것을 253대까지 동시에 인터넷을 접속할 수 있다.</li>
</ul>
<h3 id="액세스-회선-ISP-Internet-Service-Provider"><a href="#액세스-회선-ISP-Internet-Service-Provider" class="headerlink" title="액세스 회선, ISP(Internet Service Provider)"></a>액세스 회선, ISP(Internet Service Provider)</h3><ol>
<li>패킷은 인터넷의 입구에 있는 엑세스 회선(통신회선)에 의해 POP(Point of presence, 통신사용 라우터)까지 운반된다.</li>
<li>POP를 거쳐 인터넷의 핵심부로 들어가게 된다.</li>
<li>수 많은 고속 라우터들 사이로 패킷이 목적지를 향해 전송된다.</li>
</ol>
<h3 id="방화벽-캐시서버"><a href="#방화벽-캐시서버" class="headerlink" title="방화벽, 캐시서버"></a>방화벽, 캐시서버</h3><ol>
<li>패킷은 인터넷 핵심부를 통과하여 웹 서버측의 LAN에 도착한다.</li>
<li>LAN의 방화벽은 패킷을 검사한다.</li>
<li>캐시서버가 패킷이 웹 서버까지 가야하는지 가지 않아도 되는지를 판단한다.</li>
</ol>
<ul>
<li>패킷이 요구하는 데이터가 캐시서버에 있다면 웹 서버에 가지 않고 바로 그 값을 응답해준다.</li>
<li>웹 서버에서 응답하는 데이터가 다른 요청에 이용될 수 있다면 그 데이터도 캐시서버에 저장된다.</li>
</ul>
<h3 id="웹-서버"><a href="#웹-서버" class="headerlink" title="웹 서버"></a>웹 서버</h3><ol>
<li>패킷이 물리적인 웹 서버에 도착하면 웹 서버의 프로토콜 스택은 패킷을 추출하여 메세지를 복원하고 웹 서버 애플리케이션에 넘긴다.</li>
<li>메세지를 받은 웹 서버는 애플리케이션은 요청 메세지에 따른 데이터를 응답 메세지에 넣어 클라이언트로 송신한다.</li>
<li>전달된 순서의 역순으로 응답 메세지가 클라이언트에게 전달된다.</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/네트워크/">네트워크</a><a href="/tags/Network/">Network</a><a href="/tags/브라우저/">브라우저</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/03/ubuntu-파일명으로-검색/"><span>ubuntu 파일명으로 검색</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/03/ubuntu-파일명으로-검색/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-03T10:29:41.000Z">
          2019-07-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <hr>

<h1 id="ubuntu에서-파일명으로-검색하기"><a href="#ubuntu에서-파일명으로-검색하기" class="headerlink" title="ubuntu에서 파일명으로 검색하기"></a>ubuntu에서 파일명으로 검색하기</h1><hr>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find [검색할 디렉토리] -name [검색할 파일명]</span><br></pre></td></tr></table></figure>
<p>하위 디렉토리에 접근 권한이 없을 수 있으므로 sudo 명령어와 함께 사용하는 것을 추천</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/ubuntu/">ubuntu</a><a href="/tags/우분투/">우분투</a><a href="/tags/linux/">linux</a><a href="/tags/리눅스/">리눅스</a><a href="/tags/검색/">검색</a><a href="/tags/파일명/">파일명</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/03/ubuntu-user-변경/"><span>ubuntu user 변경하기</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/03/ubuntu-user-변경/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-03T10:23:07.000Z">
          2019-07-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <hr>

<h1 id="ubuntu-현재-user-변경하기"><a href="#ubuntu-현재-user-변경하기" class="headerlink" title="ubuntu 현재 user 변경하기"></a>ubuntu 현재 user 변경하기</h1><hr>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ whoami </span><br><span class="line">&gt;&gt;&gt; user1 // 현재 user를 보여준다</span><br><span class="line">$ su - user2 // user2로 변경하기</span><br><span class="line">Password: [user password 입력]</span><br><span class="line">$ whoami</span><br><span class="line">&gt;&gt;&gt; user2</span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/ubuntu/">ubuntu</a><a href="/tags/우분투/">우분투</a><a href="/tags/linux/">linux</a><a href="/tags/리눅스/">리눅스</a><a href="/tags/user/">user</a><a href="/tags/사용자/">사용자</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/07/03/umask명령어/"><span>umask 명령어</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/03/umask명령어/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-03T10:08:30.000Z">
          2019-07-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <hr>

<h1 id="umask-명령어"><a href="#umask-명령어" class="headerlink" title="umask 명령어"></a>umask 명령어</h1><hr>

<p><br><br><code>umask</code>는 the free dictionary에 의하면 user’s file creation mask입니다.</p>
<p><code>umask</code>만을 입력하면 숫자 4개가 나타나게 되는데<br>그 중 앞의 한글자를 제외하고 나머지 숫자를 이용하여 <u><strong>앞으로 해당 유저가 생성할 파일이나 디렉토리(폴더)의 접근 권한</strong></u>을 설정하거나 알 수 있습니다.</p>
<p>예를 들어</p>
<p>umask를 입력했을 시 0022를 얻었다면<br>앞으로 해당 유저가 파일을 생성했을 시 666-022 = 644<br>디렉토리를 생성했을 시 777-022 = 755를 얻을 수 있습니다.<br>여기서 644와 755가 의미하는 바는 다음과 같습니다.</p>
<p>먼저 644는 6 | 4 | 4 로 각 자리의 수를 나누어 볼 수 있는데 그 각 자리의 수를 이진법으로 바꾸어 보면 110 | 010 | 010 으로 알 수 있습니다.</p>
<p>저 세가지 이진수 중 첫 번째인 110은 rwx의 on/off를 의미하는 것으로써<br>첫 번째 1은 첫 번째 r이 on 이라는 의미고 두 번째 1은 두 번째 w가 on이라는 의미고<br>세 번째 0은 x가 off라는 의미 입니다. 이렇게 010을 해석하면 w만 on이 되었다는 것을 알 수 있습니다.<br>여기서 r이 on, w가 on, x가 off 되었다는 것을 rw-라고 표현 할 수 있으며 010에서 w만 on되었다는 것은 -w-로 표현 할 수 있습니다.</p>
<p>정리하여 644는 110 | 010 | 010 으로 표현 할 수 있으며 그것은  <code>rw--w--w-</code> 로 표현 할 수 있습니다.<br><code>rw--w--w-</code> 은 리눅스 CLI환경에서  <code>ls -al</code> 로 디렉토리의 내부를 자세히 보았을 때 볼 수 있는 그것이 맞으며<br>의미는 첫 번째 세 개의 rwx는 소유자의 r(읽기 권한), w(쓰기 권한), x(실행 권한)의 유무를 의미하며<br>두 번째 세 개의 rwx는 소유자 소속 그룹의 사용자들의 읽기, 쓰기, 실행 권한의 유무를 의미하고<br>세 번째 세 개의 rwx는 모든 사용자의 읽기, 쓰기, 실행 권한의 유무를 의미 합니다.</p>
<p>디렉토리의 경우도 다르지 않습니다.</p>
<p>umask 설정을 바꾸고 싶다면  <code>umask [변경하고 싶은 값]</code>  을 입력하시면 됩니다.</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/ubuntu/">ubuntu</a><a href="/tags/linux/">linux</a><a href="/tags/명령어/">명령어</a><a href="/tags/umask/">umask</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 younguna
    
  </p>
</footer>
    
  </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>

<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>

</body>
</html>