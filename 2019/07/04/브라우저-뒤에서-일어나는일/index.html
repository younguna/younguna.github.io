<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>브라우저 뒤에서 일어나는 일 | younguna</title>

  
  <meta name="author" content="younguna">
  

  
  <meta name="description" content="브라우저 뒤에서 일어나는 일

브라우저
URL에 입력된 값을 브라우저 내부에서 결정된 규칙에 따라 그 의미를 조사한다.
조사된 의미에 따라 HTTP Request 메세지를 만든다.
만들어진 메세지를 웹 서버로 전송한다.


이때 만들어진 메세지 전송은 브라우저가 직접하">
  

  
  
  <meta name="keywords" content="네트워크,Network,브라우저">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="브라우저 뒤에서 일어나는 일"/>

  <meta property="og:site_name" content="younguna"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="younguna" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">younguna</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>브라우저 뒤에서 일어나는 일</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/04/브라우저-뒤에서-일어나는일/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-04T05:03:47.000Z">
          2019-07-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <hr>

<h1 id="브라우저-뒤에서-일어나는-일"><a href="#브라우저-뒤에서-일어나는-일" class="headerlink" title="브라우저 뒤에서 일어나는 일"></a>브라우저 뒤에서 일어나는 일</h1><hr>

<h3 id="브라우저"><a href="#브라우저" class="headerlink" title="브라우저"></a>브라우저</h3><ol>
<li>URL에 입력된 값을 브라우저 내부에서 결정된 규칙에 따라 그 의미를 조사한다.</li>
<li>조사된 의미에 따라 HTTP Request 메세지를 만든다.</li>
<li>만들어진 메세지를 웹 서버로 전송한다.</li>
</ol>
<ul>
<li>이때 만들어진 메세지 전송은 브라우저가 직접하는 것이 아니며 OS에 의뢰하여 메세지를 전달한다.</li>
<li>OS에 송신을 의로할 때는 도메인 명이 아니라 IP주소로 메세지를 받을 상대를 지정해야 하는데 이 과정에서 DNS(Domain Name Service)에 조회한다.</li>
</ul>
<h3 id="프로토콜-스택-LAN-어댑터"><a href="#프로토콜-스택-LAN-어댑터" class="headerlink" title="프로토콜 스택, LAN 어댑터"></a>프로토콜 스택, LAN 어댑터</h3><ol>
<li>프로토콜 스택(OS에 내장된 네트워크 제어용 스프트웨어)이 브라우저로 메세지를 받는다.</li>
<li>브라우저로부터 받은 메세지를 패킷 속에 저장한다.</li>
<li>수신처 주소 등의 제어정보를 덧붙인다.</li>
<li>패킷을 LAN 어댑터에 넘긴다.</li>
<li>LAN 어댑터는 패킷을 물리적 전기적 신호로 변환시킨다.</li>
<li>신호를 LAN 케이블에 송출시킨다.</li>
</ol>
<ul>
<li>프로토콜 스택은 계층화된 구조로 모여있는 프로토콜의 집합을 의미합니다. 계층을 나누는 목적은 매우 복잡한 네트워크에서 프로토콜의 역할을 분담하기 위해서입니다. 한 계층에 속하는 하나의 프로토콜이 인접한 계층의 다른 프로토콜과 통신을 합니다.</li>
<li>프로토콜 스택은 통신 중 오류가 발생하면 이 제어 정보를 사용하여 고쳐서 전송하거나 각종 상황을 조절하는 등 다양한 역할을 수행한다.</li>
</ul>
<h3 id="허브-스위치-라우터"><a href="#허브-스위치-라우터" class="headerlink" title="허브, 스위치, 라우터"></a>허브, 스위치, 라우터</h3><ol>
<li>LAN 어댑터가 송신한 패킷은 스위칭 허브를 경유하여 인터넷 접속용 라우터에 도착한다.</li>
<li>라우터는 패킷을 서비스 프로바이더(통신사)에게 전달한다.</li>
<li>패킷은 인터넷으로 진입하게 된다.</li>
</ol>
<ul>
<li>허브는 리피터와 같이 전기적인 신호를 증폭시켜 LAN의 전송거리를 연장시키고 여러대의 장비(컴퓨터)를 연결해 LAN에 접속할 수 있도록 한다.</li>
<li>리피터는 단순히 전기적인 신호만 증폭시키는 역할을 한다. UTP케이블의 최대 전송거리가 100m이기 때문에 리피터를 이용하여 신호를 증폭시킬 수 있다.</li>
<li>스위치는 연결되어 있는 모든 장비의 IP와 MAC주소를 테이블로 유지하고 있다. 프레임이 자신에게 수신되면 그것의 목적지를 파악하여 그 디바이스에게 프레임을 보내준다. </li>
<li>라우터는 둘 혹은 그 이상의 네트워크와 네트워크 간 데이터 전송을 위해 최적 경로를 설정해 주며 데이터를 해당 경로를 따라 한 통신망에서 다른 통신망으로 통신할 수 있도록 도와주는 인터넷 접속 장비이다.</li>
<li>ISP(Internet Service Provider)업체에서 제공하는 한 개의 인터넷 IP Address로 여러대의 장비들이 인터넷을 공유할 수 있는 기능을 제공합니다. 주로 사람들이 공유기를 이야기할때는 가정에서 사용하는 소용량 라우터를 의미하며 ISP에서 할당받은 하나의 공인 IP를 내부 네트워크에서 여러개의 IP 주소로 변환 사용가능하기  때문에 한 대의 장비에서만 인터넷 접속이나 외부 네트워크와 연결되는 것을 253대까지 동시에 인터넷을 접속할 수 있다.</li>
</ul>
<h3 id="액세스-회선-ISP-Internet-Service-Provider"><a href="#액세스-회선-ISP-Internet-Service-Provider" class="headerlink" title="액세스 회선, ISP(Internet Service Provider)"></a>액세스 회선, ISP(Internet Service Provider)</h3><ol>
<li>패킷은 인터넷의 입구에 있는 엑세스 회선(통신회선)에 의해 POP(Point of presence, 통신사용 라우터)까지 운반된다.</li>
<li>POP를 거쳐 인터넷의 핵심부로 들어가게 된다.</li>
<li>수 많은 고속 라우터들 사이로 패킷이 목적지를 향해 전송된다.</li>
</ol>
<h3 id="방화벽-캐시서버"><a href="#방화벽-캐시서버" class="headerlink" title="방화벽, 캐시서버"></a>방화벽, 캐시서버</h3><ol>
<li>패킷은 인터넷 핵심부를 통과하여 웹 서버측의 LAN에 도착한다.</li>
<li>LAN의 방화벽은 패킷을 검사한다.</li>
<li>캐시서버가 패킷이 웹 서버까지 가야하는지 가지 않아도 되는지를 판단한다.</li>
</ol>
<ul>
<li>패킷이 요구하는 데이터가 캐시서버에 있다면 웹 서버에 가지 않고 바로 그 값을 응답해준다.</li>
<li>웹 서버에서 응답하는 데이터가 다른 요청에 이용될 수 있다면 그 데이터도 캐시서버에 저장된다.</li>
</ul>
<h3 id="웹-서버"><a href="#웹-서버" class="headerlink" title="웹 서버"></a>웹 서버</h3><ol>
<li>패킷이 물리적인 웹 서버에 도착하면 웹 서버의 프로토콜 스택은 패킷을 추출하여 메세지를 복원하고 웹 서버 애플리케이션에 넘긴다.</li>
<li>메세지를 받은 웹 서버는 애플리케이션은 요청 메세지에 따른 데이터를 응답 메세지에 넣어 클라이언트로 송신한다.</li>
<li>전달된 순서의 역순으로 응답 메세지가 클라이언트에게 전달된다.</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/네트워크/">네트워크</a><a href="/tags/Network/">Network</a><a href="/tags/브라우저/">브라우저</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2019 younguna
    
  </p>
</footer>
    
  </div>
</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>

<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>

</body>
</html>